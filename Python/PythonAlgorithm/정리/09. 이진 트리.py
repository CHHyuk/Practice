# 이진 트리(Binary Tree)
"""
모든 노드의 차수(자식 노드 수)가 2개 이하인 구조로 이루어진 트리이다.
이러한 구조를 가진 트리는 아래와 같이 재귀적으로 정의할 수 있다.
    1. 구조가 루트 노드 + 왼쪽 서브트리 + 오른쪽 서브트리 구조이다. 
        이때 빈 트리도 이진 트리로 간주한다!
    2. 왼쪽과 오른쪽 서브트리도 마찬가지로 이진 트리이다.
"""

# 특별한 구조를 가진 이진트리
"""
1. 포화 이진 트리
    모든 차수(Level)의 노드들이 모두 2개씩 채워져 있는 이진 트리
    높이가 k 일때 노드의 개수가 2^k -1인 이진트리다.
2. 완전 이진 트리
    높이가 k 일 때, 레벨 k-2 까지는 모든 노드가 2개의 자식을 가진 포화 이진트리 상태
    높이가 k 일 때, 레벨 k-1(마지막 노드 레벨)를 제외한 모든 노드들은 포화 이진트리 상태이며, 레벨 k-1(마지막 노드 레벨) Node들은 왼쪽부터 순차적으로 채워진다.
"""

# 이진 트리의 자료구조 구현
"""
이진 트리는 아래와 같이 3가지의 요소를 가진 구조이다.
이를 이용하여 아래와 같이 클래스를 정의할 수 있다.
"""

# 하나의 노드에 대한 정보
class Node:
	def __init__(self, item):
		self.data = item # 해당 노드의 값
		self.left = None # 자식 노드중 왼쪽 노드
		self.right = None # 자식 노드중 오른쪽 노드


# 이진 트리의 순회법(Traversal)
"""
이진 트리에서 순회하는 법은 깊이 우선 순회(depth first traversal)와 넓이 우선 순회(breadth first traversal)로 나뉜다.
"""

# 깊이 우선 순회(depth first traversal)
"""
그래프의 깊은 부분을 먼저 탐색하는 방법이다. 주로 스택과 재귀함수를 사용하며, 동작 순서는 크게 아래와 같다.
1. 탐색 시작 노드를 스택에 넣기
2. 스택의 최상단 노드에서 인접한 노드 중 방문하지 않은 노드가 있다면 그 노드를 스택에 삽입하고 방문 처리하며, 인접한 노드들 중 방문하지 않은 노드가 없다면 스택에서 최상단 노드를 꺼낸다.
3. 2번 과정을 반복하여 큐가 빈공간이 될때까지 진행합니다.
"""

# 예시 (낮은 노드를 우선 방문할 때)

## DFS 예시 코드
# v는 최상단 노드 값
def dfs(graph, v, visited):

    # 1. 현재 노드 방문 처리
    visited[v] = True

    # 2. 방문 노드 출력
    print(v, end=' ')

    for i in graph[v]:

        # 3. 방문 여부 확인
        if visited[i] != True:
            dfs(graph, i, visited)

graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

visited = [False] * len(graph)

# 1 2 7 6 8 3 4 5
dfs(graph, 1, visited)

# 넓이 우선 순회(breadth first traversal)
"""
노드의 수준(Level)이 낮은 노드를 우선으로 방문한다.
만약 같은 수준의 노드일 때는 부모 노드의 방문 순서에 따라 방문하며, 같을 경우 왼쪽 자식 노드를 오른쪽 자식보다 먼저 방문한다.
넓이 우선 순회는 재귀 방식으로 구현하기 어렵고, 큐를 사용하여 방문 순서를 기록하는 방식을 사용할 수 있다.
순서는 크게 아래와 같다.
1. 탐색 시작 노드를 큐에 넣기
2. 큐에서 해당 노드를 꺼낸 뒤, 인접한 노드 중 방문하지 않은 노드를 전부 큐에 삽입하고 방문 처리
3. 2번 과정을 반복하여 큐가 빈공간이 될때까지 진행합니다.
"""

# 예시

## BFS 예시 코드
# 큐를 사용하기 위한 모듈
from collections import deque
import queue

graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

visited = [False] * len(graph)

def bfs(graph, start, visited):
    
    # 처음 노드를 초기값으로 넣어준다.
    queue = deque([start])

    # 첫 노드를 방문처리한다.
    visited[start] = True

    # 큐에 값이 들어있다면 계속 반복
    while queue:

        # 큐에서 값 하나 출력
        v = queue.popleft()

        # 노드 값 출력
        print(v, end=" ")

        for i in graph[v]:
            if visited[i] != True:
                queue.append(i)
                visited[i] = True

# 1 2 3 8 7 4 5 6
bfs(graph, 1, visited)

